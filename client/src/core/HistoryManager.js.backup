/**
 * History manager for undo/redo functionality
 * Tracks scene state changes and allows restoration to previous states
 */
export class HistoryManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
    this.maxHistorySize = 20;
    this.isRestoring = false; // Flag to prevent history tracking during restoration
  }

  /**
   * Capture current scene state
   */
  captureState(shapeManager, selectedShapeIds = []) {
    if (this.isRestoring) return;

    // Create a snapshot of the current scene state
    const state = {
      timestamp: Date.now(),
      shapes: {},
      selectedShapes: [...selectedShapeIds]
    };

    // Capture all shape states
    for (const [id, shape] of shapeManager.shapes) {
      state.shapes[id] = {
        id: shape.id,
        type: shape.type,
        position: { ...shape.getPosition() },
        rotation: { ...shape.getRotation() },
        scale: { ...shape.getScale() },
        properties: { ...shape.properties },
        selected: shape.selected
      };
    }

    // Add to history if this is a new state (not during restoration)
    if (this.history.length === 0 ||
        !this.statesEqual(this.history[this.currentIndex], state)) {

      // Remove any history after current index (when new action is performed)
      if (this.currentIndex < this.history.length - 1) {
        this.history = this.history.slice(0, this.currentIndex + 1);
      }

      // Add new state
      this.history.push(state);
      this.currentIndex++;

      // Limit history size
      if (this.history.length > this.maxHistorySize) {
        this.history.shift();
        this.currentIndex--;
      }

  }

  /**
   * Check if two states are equal
   */
  statesEqual(state1, state2) {
    if (!state1 || !state2) return false;

    // Compare selected shapes
    if (state1.selectedShapes.length !== state2.selectedShapes.length) {
      return false;
    }

    for (let i = 0; i < state1.selectedShapes.length; i++) {
      if (state1.selectedShapes[i] !== state2.selectedShapes[i]) {
        return false;
      }
    }

    // Compare shape counts
    if (Object.keys(state1.shapes).length !== Object.keys(state2.shapes).length) {
      return false;
    }

    // Compare each shape
    for (const id in state1.shapes) {
      if (!state2.shapes[id]) return false;

      const shape1 = state1.shapes[id];
      const shape2 = state2.shapes[id];

      if (shape1.type !== shape2.type ||
          !this.positionsEqual(shape1.position, shape2.position) ||
          !this.rotationsEqual(shape1.rotation, shape2.rotation) ||
          !this.scalesEqual(shape1.scale, shape2.scale)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Check if two positions are approximately equal
   */
  positionsEqual(pos1, pos2, tolerance = 0.01) {
    return Math.abs(pos1.x - pos2.x) < tolerance &&
           Math.abs(pos1.y - pos2.y) < tolerance &&
           Math.abs(pos1.z - pos2.z) < tolerance;
  }

  /**
   * Check if two rotations are approximately equal
   */
  rotationsEqual(rot1, rot2, tolerance = 0.01) {
    return Math.abs(rot1.x - rot2.x) < tolerance &&
           Math.abs(rot1.y - rot2.y) < tolerance &&
           Math.abs(rot1.z - rot2.z) < tolerance;
  }

  /**
   * Check if two scales are approximately equal
   */
  scalesEqual(scale1, scale2, tolerance = 0.01) {
    return Math.abs(scale1.x - scale2.x) < tolerance &&
           Math.abs(scale1.y - scale2.y) < tolerance &&
           Math.abs(scale1.z - scale2.z) < tolerance;
  }

  /**
   * Undo to previous state
   */
  undo(shapeManager) {
    if (!this.canUndo()) return false;

    this.isRestoring = true;

    try {
      const previousState = this.history[this.currentIndex - 1];

      // Restore scene to previous state
      this.restoreState(shapeManager, previousState);

      this.currentIndex--;
      return true;
    } finally {
      this.isRestoring = false;
    }
  }

  /**
   * Check if undo is possible
   */
  canUndo() {
    return this.currentIndex > 0;
  }

  /**
   * Check if redo is possible
   */
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }

  /**
   * Redo to next state
   */
  redo(shapeManager) {
    if (!this.canRedo()) return false;

    this.isRestoring = true;

    try {
      const nextState = this.history[this.currentIndex + 1];

      // Restore scene to next state
      this.restoreState(shapeManager, nextState);

      this.currentIndex++;
      return true;
    } finally {
      this.isRestoring = false;
    }
  }

  /**
   * Restore scene to a specific state
   */
  restoreState(shapeManager, state) {
    // Clear current selection
    shapeManager.clearSelection();

    // Remove all existing shapes
    for (const [id, shape] of shapeManager.shapes) {
      shapeManager.scene.remove(shape.mesh);
      shape.dispose();
    }
    shapeManager.shapes.clear();

    // Restore shapes from state
    for (const id in state.shapes) {
      const shapeData = state.shapes[id];

      // Create shape using factory
      const shape = shapeManager.factory.createFromData(shapeData);

      if (shape) {
        shapeManager.shapes.set(shape.id, shape);
        shapeManager.scene.add(shape.mesh);

        // Restore selection state
        if (shapeData.selected) {
          shape.setSelected(true);
        }
      }
    }

    // Restore selected shapes set
    shapeManager.selectedShapes = new Set(state.selectedShapes);
  }

  /**
   * Clear all history
   */
  clear() {
    this.history = [];
    this.currentIndex = -1;
  }

  /**
   * Get current history size
   */
  getHistorySize() {
    return this.history.length;
  }

  /**
   * Get current history index
   */
  getCurrentIndex() {
    return this.currentIndex;
  }
}
